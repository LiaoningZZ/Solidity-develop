# Solidity零基础入门笔记: 4_Data Element (数据类型)

## 标识符

在编程过程中，我们经常需要定义一些符号来标记一些数据或内容，如变量名、方法名、参数名、数组名等，这些符号被称为标识符。
标识符的命名需要遵循一些规范：
标识符只能由字母、数字和下划线组成，例如：lisson_1；
标识符不能以数字作为第一个字符，例如：3a，这就是错的；
标识符不能使用关键字，例如uint，这就是错的；
标识符区分大小写字母，如Abc、ABC是不同的标识符
## 常量与变量
常量的值一直保持不变，而变量的数值可以改变。

如1、1.5、π等，这些值是不可变的，这些称之为常量。

除了常量之外，一些可以变化的量，例如钱包金额的变化，要用一个标识符X记录不同时间金额的值，与常量不同，标识符X的值是可以不断改变，

因此X就称为一个变量。变量在程序中会经常使用，这些变量被存储在内存单元中，为了访问、使用和修改内存单元中的数据，我们用标识符来标识

存储数据的内存单元，这些用于标识内存单元的标识符被称为变量名，内存单元中存储的数据被称为变量的值。

## 数据类型
数据类型用于声明不同类型的变量或函数，变量的类型决定了变量存储占用的空间以及存储模式。

Solidity的数据类型分为

1. **值类型(Value Type)**：包括布尔型、整型、定长浮点型、地址类型、定长字节数组、地址字面常数、有理数和整数字面常数、字符串字面常数、十六进制字面常数、枚举类型、函数类型。

2. **引用类型(Reference Type)**：包括数组和结构体。

3. **映射类型(Mapping Type)**: `Solidity`里的哈希表（https://en.wikipedia.org/wiki/Hash_table）。
## 数值类型
### 1. 布尔型
布尔型是二值变量，取值为`true`或`false`。
```solidity
    // 布尔值
    bool public _bool = true;
```
布尔值的运算符（运算符是什么，后面单独讲），包括：

- `!` （逻辑非）
- `&&` （逻辑与， "and" ）
- `||` （逻辑或， "or" ）
- `==` （等于）
- `!=` （不等于）
### 2. 整型
例如0、1、-1这些不包含小数部分的数据称为整型。可以将整形分为int（整数包括负数）、uint（正整数）

支持关键字 uint8 到 uint256 （无符号，从 8 位到 256 位）以及 int8 到 int256，以 8 位为步长递增。 

uint 和 int 分别是 uint256 和 int256 的别名。

常用的整型运算符包括：

- 比较运算符（返回布尔值）： `<=`， `<`， `==`， `!=`， `>=`， `>` 
- 位运算符： ` &` ， ` |` ， ` ^ `（异或）， ` ~ `（位取反）
- 算数运算符： `+`， `-`， 一元运算 `-`， `+`， `*`， `/`， `%`（取余），`**`（幂）`<<` （左移位） ， `>>`（右移位）

- `字节`
这里讲一下字节的概念。字节（Byte）是计算机存储空间的一种单位，它是内存分配空间的一个基础单位，即内存分配空间至少是1个字节。
 
最小的存储单位—位（bit，b）：一个二进制数字0或1占一位。

- 字节（Byte，B）：1B=8bit；一个英文字母占一个字节。

- 千字节（KiloByte，KB）：1KB=1024B。

- 兆字节（MegaByte，MB）：1MB=1024KB。

- 吉字节（GigaByte，GB）：1GB=1024MB。

- 太字节（TeraByte，TB）：1TB=1024GB。

- `进制`
进制是一种计数机制，X进制表示某一位置上的数在运算时逢X进一位。计算机通常使用二进制、十六进制。

- 二进制：二进制是一种“逢二进一”的计数机制，它由0和1两个符号描述。

二进制转化成十进制要从右到左用二进制位上的每个数去乘以2的相应次方，即将最右边第1位的数乘以2的0次方，

第2位的数乘以2的1次方，第n位的数乘以2的n-1次方，然后把所有乘的结果相加，得到的结果就是转换后的十进制。

十进制转换成二进制可以采用将要转换的数先除以2，得到商和余数，将商继续除以2，获得商和余数，

此过程一直重复直到商为0，最后将所有得到的余数倒序排列，即可得到转换结果。

例如：1110，代表我们日常所说的14（2*2的3次方+2*2的2次方+2*2的1次方+2*2的0次方）

- 十六进制（十六进制用字面常量使用0x开头）：十六进制是一种“逢十六进一”的进制，它由0～9、A～F（或a～f）这16个符号来描述，A～F分别对应十进制的10～15。

不管是用哪种进制形式来表示数据，那个数本身是不会发生变化的，变得只是我们采用的进制。

所以二进制的1110=十进制的14=十六进制的0xE
### 3. 定长浮点型
fixed：各种大小的有符号的定长浮点型。
ufixed：表示无符号的定长浮点型。 

用关键字 ufixedMxN 和 fixedMxN 表示，其中M 表示该类型占用的位数，N 表示可用的小数位数。 M 必须能整除 8，即 8 到 256 位。 N 则可以是从 0 到 80 之间的任意数。 ufixed 和 fixed 分别是 ufixed128x19 和 fixed128x19 的别名。

### 4. 地址类型
address：地址类型存储一个 20 字节的值（以太坊地址的大小）。 地址类型也有成员变量，并作为所有合约的基础。例如：0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2。

这里讲一下地址类型成员变量balance 和 transfer。可以使用 balance 属性来查询一个地址的余额， 也可以使用 transfer 函数向一个地址发送 以太币Ether （以 wei 为单位）：

```solidity
    // 如果 x 是一个合约地址，它的代码会跟 transfer 函数调用一起执行。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，以太币Ether 交易会被打回，当前的合约也会在终止的同时抛出异常。
    address x = 0x123;
    address myAddress = this;
    if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);
```

### 5. 定长字节数组

定长字节数组bytes，关键字有：bytes1， bytes2， bytes3， ...， bytes32。byte 是 bytes1 的别名。定长字节数组不属于值的范围。

### 6. 定长字节数组地址字面常数（Address Literals）
比如像 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF 这样的通过了地址校验和测试的十六进制字面常数属于 address 类型。 长度在 39 到 41 个数字的，没有通过校验和测试而产生了一个警告的十六进制字面常数视为正常的有理数字面常数。

### 7. 有理数和整数字面常数
整数字面常数由范围在 0-9 的一串数字组成，表现成十进制。 例如，69 表示数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。

### 8. 字符串字面常数
字符串字面常数是指由双引号或单引号引起来的字符串（"foo" 或者 'bar'）。 不像在 C 语言中那样带有结束符；"foo" 相当于 3 个字节而不是 4 个。 和整数字面常数一样，字符串字面常数的类型也可以发生改变，但它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。

字符串字面常数支持转义字符，例如 \n，\xNN 和 \uNNNN。\xNN 表示一个 16 进制值，最终转换成合适的字节， 而 \uNNNN 表示 Unicode 编码值，最终会转换为 UTF-8 的序列。

### 9. 十六进制字面常数
十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex"001122FF"）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。

十六进制字面常数跟字符串字面常数很类似，具有相同的转换规则。

### 10. 枚举类型
枚举enum，在日常生活中有许多对象的值是有限的，可以一一列举的，如一年有四季，一个星期只有周一到周日等，这种称为“枚举”的类型。枚举类型用于定义值可以被一一列举的变量。

### 11. 函数类型
函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量，也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 函数类型有两类：- 内部（internal） 函数和 外部（external） 函数：

内部函数只能在当前合约内被调用（更具体来说，在当前代码块内，包括内部库函数和继承的函数中），因为它们不能在当前合约上下文的外部被执行。 调用一个内部函数是通过跳转到它的入口标签来实现的，就像在当前合约的内部调用一个函数。

外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。

函数类型表示成如下的形式

```solidity
function (<parameter types>) {internal|external} [pure|constant|view|payable] [returns (<return types>)]
```
与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，则需要删除整个 returns (<return types>) 部分。

函数类型默认是内部函数，因此不需要声明 internal 关键字。 与此相反的是，合约中的函数本身默认是 public 的，只有当它被当做类型名称时，默认才是内部函数。

有两种方法可以访问当前合约中的函数：一种是直接使用它的名字，f ，另一种是使用 this.f 。 前者适用于内部函数，后者适用于外部函数。

如果当函数类型的变量还没有初始化时就调用它的话会引发一个异常。 如果在一个函数被 delete 之后调用它也会发生相同的情况。

如果外部函数类型在 Solidity 的上下文环境以外的地方使用，它们会被视为 function 类型。 该类型将函数地址紧跟其函数标识一起编码为一个 bytes24 类型。。

请注意，当前合约的 public 函数既可以被当作内部函数也可以被当作外部函数使用。 如果想将一个函数当作内部函数使用，就用 f 调用，如果想将其当作外部函数，使用 this.f 。

##  引用类型
###  1.数组
数组是一组具有相同数据类型的变量集合，这些变量称为数组的元素，数组的类型由数组中存储的元素的类型决定。定义数组时要指定数组类型、数组大小。

一个元素类型为 T，固定长度为 k 的数组可以声明为 T[k]，而动态数组声明为 T[]。 举个例子，一个长度为 5，元素类型为 uint 的动态数组的数组，应声明为 uint[][5] （注意这里跟其它语言比，数组长度的声明位置是反的）。 

要访问第三个动态数组的第二个元素，你应该使用 x[2][1]（数组下标是从 0 开始的，且访问数组时的下标顺序与声明时相反，也就是说，x[2] 是从右边减少了一级）。

###  2.结构体

结构体使用关键字struct定义。结构体可以将不同数据类型的变量整合在一起，结构体中的所有成员都占有内存，在引用结构体变量时，所有成员都有效。

```solidity
    // 结构体
   struct Funder {
        address addr;
        uint amount;
    }
```
